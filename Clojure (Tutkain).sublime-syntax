%YAML 1.2
---
# https://www.sublimetext.com/docs/syntax.html
name: Clojure (Tutkain)
file_extensions: [clj, cljc]
scope: source.clojure

variables:
  whitespace: '(?:\s|(,))*'
  end: '(?=$|[\s,()\[\]{}";])'
  number_end: '(?=$|[\s,()\[\]{}";''`#])'
  non_symbol_chars: \s,;\(\)\[\]{}\"`~@\^\\\/
  non_symbol_start_chars: '{{non_symbol_chars}}\d#'':'
  symbol: (?:/|[^{{non_symbol_start_chars}}][^{{non_symbol_chars}}]*)
  qualified_symbol: '(?:{{symbol}}|({{symbol}})(/)({{symbol}})?){{end}}'
  keyword_chars: '[^{{non_symbol_chars}}:]'
  keyword_namespace: '[{{keyword_chars}}:]*'
  keyword: '[{{keyword_chars}}|/][{{keyword_chars}}:/]*'
  constant: '(nil|true|false){{end}}'
  regexp_name: '[a-zA-Z][a-zA-Z0-9]*'
  sign: '[-+]?'
  exponent: (?:[eE]{{sign}}\d+)

contexts:
  main:
    - include: stray-brackets
    - include: forms

  # https://clojure.org/reference/reader
  forms:
    - include: constant

    # Literals
    - include: string
    - include: numbers
    - include: symbolic
    - include: keywords

    # Macro characters
    - include: quote
    - include: character
    - include: comment
    - include: deref
    - include: metadata
    - include: dispatch
    - include: syntax-quote

    # S-expressions
    - include: sexp

    # Comma
    - match: ','
      scope: punctuation.comma.clojure comment.punctuation.comma.clojure

    # Symbols
    - include: symbol

    # Fallback?
    - match: '[^\s,;\(\)\[\]{}\"`~@\^\\]+'

  # Constants

  constant:
    - match: '{{constant}}'
      scope: constant.language.clojure

  # Symbols

  symbol:
    - match: '{{qualified_symbol}}'
      scope: meta.reader-form.clojure meta.symbol.clojure
      captures:
        1: meta.namespace.clojure
        2: punctuation.accessor.clojure

  # Literals

  string:
    - match: '"'
      scope: meta.sexp.begin.clojure punctuation.definition.string.begin.clojure
      push:
      - meta_scope: meta.reader-form.clojure string.quoted.double.clojure
      - match: '(\\)(u\h{4}|b|t|n|f|r|"|''|\\|[0-3]?[0-7]{1,2})|((\\).)'
        scope: constant.character.escape.clojure
        captures:
          1: punctuation.definition.character.escape.begin.clojure
          3: invalid.illegal.escape.string.clojure
          4: punctuation.definition.character.escape.begin.clojure
      - match: '"'
        scope: meta.sexp.end.clojure punctuation.definition.string.end.clojure
        pop: true

  numbers:
    - include: deprecated
    - include: integer_with_radix
    - include: hex_integer
    - include: decimal_integer
    - include: float
    - include: ratio

  deprecated:
    - match: '[-+]?0\d+N?{{number_end}}'
      scope: meta.reader-form.clojure invalid.deprecated.clojure
      pop: true

  integer_with_radix:
    - match: '([-+]?)((?:[2-9]|[1-9]\d+)[Rr])[0-9A-Za-z]+{{number_end}}'
      scope: meta.reader-form.clojure constant.numeric.integer.other.clojure
      captures:
        1: punctuation.definition.numeric.sign.clojure
        2: punctuation.definition.numeric.base.clojure

  hex_integer:
    - match: '([-+]?)(0[Xx])\h+(N?){{number_end}}'
      scope: meta.reader-form.clojure constant.numeric.integer.hexadecimal.clojure
      captures:
        1: punctuation.definition.numeric.sign.clojure
        2: punctuation.definition.numeric.base.clojure
        3: storage.type.numeric.clojure

  decimal_integer:
    - match: '({{sign}})\d+(N?){{number_end}}'
      scope: meta.reader-form.clojure constant.numeric.integer.decimal.clojure
      captures:
        1: punctuation.definition.numeric.sign.clojure
        2: storage.type.numeric.clojure

  float:
    - match: '({{sign}})\d+(?:(?:(\.)\d+{{exponent}}?|{{exponent}})(M)?|(M)){{number_end}}'
      scope: meta.reader-form.clojure constant.numeric.float.decimal.clojure
      captures:
        1: punctuation.definition.numeric.sign.clojure
        2: punctuation.separator.decimal.clojure
        3: storage.type.numeric.clojure
        4: storage.type.numeric.clojure

  ratio:
    - match: '({{sign}})\d+(/)\d+{{number_end}}'
      scope: meta.reader-form.clojure constant.numeric.rational.decimal.clojure
      captures:
        1: punctuation.definition.numeric.sign.clojure
        2: punctuation.separator.rational.clojure

  symbolic:
    - match: '((##)(Inf)|(##)(-Inf)|(##)(NaN))'
      captures:
        1: meta.reader-form.clojure
        2: keyword.operator.macro.clojure
        3: constant.other.symbolic.clojure
        4: keyword.operator.macro.clojure
        5: constant.other.symbolic.clojure
        6: keyword.operator.macro.clojure
        7: constant.other.symbolic.clojure

  keywords:
    - include: auto_qualified_keyword
    - include: qualified_keyword
    - include: unqualified_keyword

  auto_qualified_keyword:
    - match: '(::)(?=[^:])({{keyword_namespace}})((/)({{keyword}}))?'
      scope: meta.reader-form.clojure constant.other.keyword.auto-qualified.clojure
      captures:
        1: punctuation.definition.keyword.clojure
        2: meta.namespace.clojure
        4: punctuation.definition.constant.namespace.clojure

  qualified_keyword:
    - match: '(:)({{keyword_namespace}})(/)({{keyword}})'
      scope: meta.reader-form.clojure constant.other.keyword.qualified.clojure
      captures:
        1: punctuation.definition.keyword.clojure
        2: meta.namespace.clojure
        3: punctuation.definition.constant.namespace.clojure

  unqualified_keyword:
    - match: '(:){{keyword}}'
      scope: meta.reader-form.clojure constant.other.keyword.unqualified.clojure
      captures:
        1: punctuation.definition.keyword.clojure

  # Macro characters

  quote:
    - match: '(''){{whitespace}}'
      captures:
        1: meta.quoted.begin.clojure keyword.operator.macro.clojure
      push:
        - meta_scope: meta.quoted.clojure
        - include: forms
        - match: ''
          pop: true

  character:
    - match: '((\\)(u\h{4}|o[0-3]?[0-7]{1,2}|newline|tab|space|backspace|formfeed|return|[^\s])|((\\)[^\s,()\[\]{}";]*))'
      scope: meta.reader-form.clojure constant.character.clojure
      captures:
        2: punctuation.definition.character.begin.clojure
        4: invalid.illegal.character.clojure
        5: punctuation.definition.character.begin.clojure

  comment:
    - match: '(;+|#!)(.|\s)*'
      scope: comment.line.clojure
      captures:
        1: punctuation.definition.comment.clojure

  deref:
    - match: '(@){{whitespace}}'
      captures:
        1: meta.sexp.prefix.clojure meta.reader-form.clojure keyword.operator.macro.clojure
      push:
        - meta_scope: meta.deref.clojure
        - include: forms
        - match: ''
          pop: true

  metadata:
    - match: '(\^){{whitespace}}'
      scope: keyword.operator.macro.clojure
      captures:
        1: meta.metadata.begin.clojure punctuation.definition.metadata.begin.clojure
      push:
        - meta_scope: meta.metadata.clojure
        - include: map
        - include: keywords
        - include: symbol
        - include: string
        - match: ''
          pop: true

  dispatch:
    - include: discard
    - include: regexp
    - include: var-quote
    - include: anonymous-function-literal
    - include: reader-conditional
    - include: tagged-literal
    - include: qualified-map

  # Dispatch

  discard:
    - match: '(#_)'
      captures:
        1: meta.sexp.prefix.clojure punctuation.definition.comment.clojure
      push:
        - meta_scope: meta.discarded.clojure comment.block.clojure
        - include: forms
        - match: ''
          pop: true

  regexp_quote:
    - match: '\\Q'
      scope: punctuation.section.quotation.begin.clojure
      push:
        - meta_content_scope: constant.character.escape.regexp
        - match: '\\"'
        - match: '(?=")'
          pop: true
        - match: '\\E'
          scope: punctuation.section.quotation.end.clojure
          pop: true

  regexp_shared:
    - match: '(\\)(\\|0[0-3]?[0-7]{1,2}|x\h{2}|u\h{4}|x\{1?\h{1,5}\}|\N\{[a-zA-Z0-9\- ]+\}|[tnrfae]|c[A-Z]|[dDhHsSvVwW]|p\{[a-zA-Z]+\}|b\{g\}|[bBAGZz]|[RX]|[0-9]+|k<{{regexp_name}}>|[^a-zA-Z0-9])|((\\).)'
      scope: constant.character.escape.regexp
      captures:
          1: punctuation.definition.character.escape.begin.clojure
          3: invalid.illegal.escape.regexp.clojure
          4: punctuation.definition.character.escape.begin.clojure
    - match: '"'
      scope: punctuation.definition.string.end.clojure
      pop: true
    - match: '(\[)(\^)?(-)?'
      captures:
        1: punctuation.section.brackets.begin.clojure
        2: keyword.operator.negation.regexp.clojure
      push:
      - match: '(?=")'
        pop:   true
      - match: '\]'
        scope: punctuation.section.brackets.end.clojure
        pop: true
      - match: '-(?!\])'
        scope: keyword.operator.range.regexp.clojure
      - match: '&&'
        scope: keyword.operator.intersection.regexp.clojure
      - include: regexp_shared
    - match: '(?:[?*+]|\{\d+(?:,(?:\d+)?)?\})[?+]?'
      scope: keyword.operator.quantifier.regexp.clojure

  regexp_group:
    - include: regexp_quote
    - include: regexp_shared
    - match: '\|'
      scope: keyword.operator.union.regexp.clojure
    - match: '(\()(\?(<{{regexp_name}}>|:|=|!|<=|<!|>|[idmsux]*(-[idmsux]+)?:|[idmsuxU]*(-[idmsuxU]+)?(?!:)))?'
      captures:
        1: punctuation.section.parens.begin.clojure
        2: keyword.operator.special.regexp.clojure
      push:
      - match: '(?=")'
        pop:   true
      - match: '\)'
        scope: punctuation.section.parens.end.clojure
        pop: true
      - include: regexp_group
    - match: '[\)]'
      scope: invalid.illegal.stray-bracket-end.clojure

  regexp:
    - match: '(#)"'
      scope: punctuation.definition.string.begin.clojure
      captures:
        1: keyword.operator.macro.clojure
      push:
      - meta_scope: meta.reader-form.clojure string.regexp.clojure
      - include: regexp_group

  var-quote:
    - match: '(#''){{whitespace}}'
      captures:
        1: meta.quoted.begin.clojure keyword.operator.macro.clojure
        2: punctuation.definition.comma.clojure
      push:
        - meta_scope: meta.quoted.var.clojure
        - include: forms
        - match: ''
          pop: true

  anonymous-function-literal:
    - match: '(#)(?=\()'
      captures:
        1: meta.sexp.prefix.clojure keyword.operator.macro.clojure
      push:
        - meta_scope: meta.sexp.clojure
        - include: forms
        - match: ''
          pop: true

  reader-conditional:
    - match: '(#\?@?){{whitespace}}'
      captures:
        1: meta.sexp.prefix.clojure keyword.operator.macro.clojure
      push:
        - meta_scope: meta.sexp.clojure
        - include: forms
        - match: ''
          pop: true

  tagged-literal:
    - match: '((#\s*inst)\s*((")\d\d\d\d(?:-[01]\d(?:-[0123]\d(?:T[012]\d(?::[012345]\d(?::[0123456]\d(?:[.]\d{1,9})?)?)?)?)?)?(?:Z|[-+][012]\d:[012345]\d)?("))|(#inst\s*"[^"]*")){{end}}'
      scope: meta.reader-form.clojure constant.other.instant.clojure
      captures:
        2: keyword.operator.macro.clojure
        3: string.quoted.double.clojure
        4: punctuation.definition.string.begin.clojure
        5: punctuation.definition.string.end.clojure
        6: invalid.illegal.instant.clojure
    - match: '((#\s*uuid)\s*((")\h{8}-\h{4}-\h{4}-\h{4}-\h{12}("))|(#uuid\s*"[^"]*")){{end}}'
      scope: meta.reader-form.clojure constant.other.uuid.clojure
      captures:
        2: keyword.operator.macro.clojure
        3: string.quoted.double.clojure
        4: punctuation.definition.string.begin.clojure
        5: punctuation.definition.string.end.clojure
        6: invalid.illegal.uuid.clojure
    - match: '(#{{qualified_symbol}}){{whitespace}}'
      captures:
        1: keyword.operator.macro.clojure
        3: punctuation.definition.symbol.namespace.clojure
      push:
        - meta_scope: meta.reader-form.clojure
        - include: forms
        - match: ''
          pop: true

  qualified-map:
    - match: '(#)(?=:)'
      captures:
          1: keyword.operator.macro.clojure
      push:
        - meta_scope: meta.map.qualified.clojure
        - include: keywords
        - include: map
        - match: ''
          pop: true

  syntax-quote:
    - match: '(~@?){{whitespace}}'
      captures:
        1: keyword.operator.macro.clojure
        2: punctuation.definition.comma.clojure
      push:
        - meta_scope: meta.unquoted.clojure
        - include: forms
        - match: ''
          pop: true
    - match: '(`){{whitespace}}'
      captures:
        1: keyword.operator.macro.clojure
        2: punctuation.definition.comma.clojure
      push:
        - meta_scope: meta.quoted.syntax.clojure
        - include: forms
        - match: ''
          pop: true

  # S-expressions

  sexp:
    - include: list
    - include: vector
    - include: map
    - include: set

  # List

  list:
    - match: '\('
      scope: meta.sexp.begin.clojure punctuation.section.parens.begin.clojure
      push: list-head

  list-head:
    - include: list-end
    - include: metadata
    - include: comment
    - include: special-forms
    - match: '(ns|in-ns){{end}}'
      scope: keyword.declaration.namespace.clojure
      set:
        - match: '{{symbol}}'
          scope: meta.reader-form.clojure meta.symbol.clojure entity.name.namespace.clojure
          set: ns-tail
        - include: list-tail
    - match: 'defmulti{{end}}'
      scope: keyword.declaration.function.clojure
      set: defmulti-tail
    - match: 'defmethod{{end}}'
      scope: keyword.declaration.function.clojure
      set: defmethod-tail
    - match: '(defrecord|deftype){{end}}'
      scope: storage.type.class.clojure
      set: classdef-tail
    - match: '(defprotocol|definterface){{end}}'
      scope: storage.type.interface.clojure
      set: typedef-tail
    - match: 'declare{{end}}'
      scope: keyword.declaration.variable.clojure
      set: declare-tail
    - match: 'defonce{{end}}'
      scope: keyword.declaration.variable.clojure
      set: def-tail
    - match: 'defn(-?){{end}}'
      scope: keyword.declaration.function.clojure
      set: fn-tail
    - match: 'defmacro{{end}}'
      scope: keyword.declaration.macro.clojure
      set: fn-tail
    - match: '((?:.+?/)?deftest){{end}}'
      captures:
        1: keyword.declaration.function.clojure
      set: deftest-tail
    - match: '(?:reify|proxy|extend-protocol|extend-type){{end}}'
      scope: variable.function.clojure
      set: class-specs
    - match: '(?=\S)'
      set:
        - match: '{{constant}}'
          scope: constant.language.clojure
          set: list-tail
        - match: '{{qualified_symbol}}'
          captures:
            1: meta.namespace.clojure
            2: punctuation.accessor.clojure
          scope: meta.reader-form.clojure meta.symbol.clojure variable.function.clojure
          set: list-tail
        - match: (?=\S)
          set: list-tail
        - include: list-tail

  let-tail:
    - include: list-end
    - match: '\['
      scope: meta.sexp.begin.clojure punctuation.section.brackets.begin.clojure
      push:
      - meta_scope: meta.binding-vector.clojure
      - match: '\]'
        scope: meta.sexp.end.clojure punctuation.section.brackets.end.clojure
        pop: 2
      - include: forms

  special-forms:
    - match: 'def{{end}}'
      scope: meta.special-form.clojure keyword.declaration.variable.clojure
      set: def-tail
    - match: 'if{{end}}'
      scope: meta.special-form.clojure keyword.control.conditional.if.clojure
      set: list-tail
    - match: 'do{{end}}'
      scope: meta.special-form.clojure keyword.other.clojure
      set: list-tail
    - match: 'let\*?{{end}}'
      scope: meta.special-form.clojure keyword.declaration.variable.clojure
      push: let-tail
    - match: 'quote{{end}}'
      scope: meta.special-form.clojure keyword.other.clojure
      set: list-tail
    - match: 'var{{end}}'
      scope: meta.special-form.clojure keyword.other.clojure
      set: list-tail
    - match: 'fn\*?{{end}}'
      scope: meta.special-form.clojure keyword.declaration.function.inline.clojure
      set: fn-tail
    - match: 'loop{{end}}'
      scope: meta.special-form.clojure keyword.control.loop.clojure
      set: list-tail
    - match: 'recur{{end}}'
      scope: meta.special-form.clojure keyword.control.flow.recur.clojure
      set: list-tail
    - match: 'throw{{end}}'
      scope: meta.special-form.clojure keyword.control.flow.throw.clojure
      set: list-tail
    - match: 'try{{end}}'
      scope: meta.special-form.clojure keyword.control.exception.try.clojure
      set: list-tail
    - match: 'catch{{end}}'
      scope: keyword.control.exception.catch.clojure
      set: list-tail
    - match: 'finally{{end}}'
      scope: keyword.control.exception.finally.clojure
      set: list-tail
    - match: '(monitor-enter|monitor-exit){{end}}'
      scope: meta.special-form.clojure keyword.other.clojure
      set: list-tail

  ns-tail:
    - match: '\('
      scope: meta.sexp.begin.clojure punctuation.section.parens.begin.clojure
      push:
      - include: list-end
      - match: ':require{{end}}'
        scope: meta.reader-form.clojure meta.statement.require.clojure constant.other.keyword.unqualified.clojure
        set: list-tail
      - match: ':import{{end}}'
        scope: meta.reader-form.clojure meta.statement.import.clojure constant.other.keyword.unqualified.clojure
        set: list-tail
      - include: list-tail
    - include: list-tail

  fn-params-2:
    - match: '\['
      scope: meta.sexp.begin.clojure punctuation.section.brackets.begin.clojure
      push:
        - meta_scope: meta.function.parameters.clojure
        - match: '\]'
          scope: meta.sexp.end.clojure punctuation.section.brackets.end.clojure
          set:
            - match: '\)'
              scope: meta.sexp.end.clojure punctuation.section.parens.end.clojure
              pop: 2
            - include: main
        - include: main

  fn-params-3:
    - match: '\['
      scope: meta.sexp.begin.clojure punctuation.section.brackets.begin.clojure
      push:
        - meta_scope: meta.function.parameters.clojure
        - match: '\]'
          scope: meta.sexp.end.clojure punctuation.section.brackets.end.clojure
          set:
            - match: '\)'
              scope: meta.sexp.end.clojure punctuation.section.parens.end.clojure
              pop: 3
            - include: main
        - include: main

  arglists-2:
    - include: comment
    - include: string
    - include: map
    - include: fn-params-2
    - match: '\('
      scope: meta.sexp.begin.clojure punctuation.section.parens.begin.clojure
      push:
        - meta_scope: meta.function-body.clojure
        - include: list-end
        - include: comment
        - include: metadata
        - match: '\['
          scope: meta.sexp.begin.clojure punctuation.section.brackets.begin.clojure
          push:
            - meta_scope: meta.function.parameters.clojure
            - match: '\]'
              scope: meta.sexp.end.clojure punctuation.section.brackets.end.clojure
              set:
                - match: '\)'
                  scope: meta.sexp.end.clojure punctuation.section.parens.end.clojure
                  pop: 2
                - include: main
            - include: main

  arglists-3:
    - include: comment
    - include: string
    - include: map
    - include: fn-params-3
    - match: '\('
      scope: meta.sexp.begin.clojure punctuation.section.parens.begin.clojure
      push:
        - meta_scope: meta.function-body.clojure
        - include: list-end
        - include: comment
        - include: metadata
        - match: '\['
          scope: meta.sexp.begin.clojure punctuation.section.brackets.begin.clojure
          push:
            - meta_scope: meta.function.parameters.clojure
            - match: '\]'
              scope: meta.sexp.end.clojure punctuation.section.brackets.end.clojure
              set:
                - match: '\)'
                  scope: meta.sexp.end.clojure punctuation.section.parens.end.clojure
                  pop: 3
                - include: main
            - include: main

  fn-tail:
    - meta_content_scope: meta.function.clojure
    - match: '\)'
      scope: meta.sexp.end.clojure punctuation.section.parens.end.clojure
      pop: true
    - include: metadata
    - include: comment
    - match: '{{symbol}}'
      scope: meta.reader-form.clojure meta.symbol.clojure entity.name.function.clojure
      push: arglists-3
    - include: arglists-2

  defmulti-tail:
    - match: '{{qualified_symbol}}'
      scope: meta.reader-form.clojure meta.symbol.clojure entity.name.function.clojure
      set: list-tail
    - include: list-tail

  defmethod-tail:
    - include: comment
    - match: '{{qualified_symbol}}'
      scope: meta.reader-form.clojure meta.symbol.clojure entity.name.function.clojure
      push:
        - match: '(?=[^\s|(,)])'
          set:
          - include: forms
          - match: ''
            set:
              - match: '\['
                scope: meta.sexp.begin.clojure punctuation.section.brackets.begin.clojure
                push:
                  - meta_scope: meta.function.parameters.clojure
                  - match: '\]'
                    scope: meta.sexp.end.clojure punctuation.section.brackets.end.clojure
                    set:
                      - match: '\)'
                        scope: meta.sexp.end.clojure punctuation.section.parens.end.clojure
                        set: main
                      - include: main
                  - include: main

  class-specs:
    - include: comment
    - match: '\)'
      scope: meta.sexp.end.clojure punctuation.section.parens.end.clojure
      set: main
    - match: '{{qualified_symbol}}'
      scope: meta.reader-form.clojure meta.symbol.clojure entity.other.inherited-class.clojure
    - match: '\('
      scope: meta.sexp.begin.clojure punctuation.section.parens.begin.clojure
      push:
        - match: '\)'
          scope: meta.sexp.end.clojure punctuation.section.parens.end.clojure
          set: class-specs
        - include: constant
        - match: '{{symbol}}'
          scope: meta.reader-form.clojure meta.symbol.clojure entity.name.function.clojure
          push:
          - match: '\['
            scope: meta.sexp.begin.clojure punctuation.section.brackets.begin.clojure
            set:
            - meta_scope: meta.function.parameters.clojure
            - match: '\]'
              scope: meta.sexp.end.clojure punctuation.section.brackets.end.clojure
              set:
                - match: '\)'
                  scope: meta.sexp.end.clojure punctuation.section.parens.end.clojure
                  set: class-specs
                - include: forms
          - include: forms

  classdef-tail:
    - include: metadata
    - include: comment
    - match: '{{symbol}}'
      scope: meta.reader-form.clojure meta.symbol.clojure entity.name.type.clojure
      set:
        - include: list-end
        - include: comment
        - match: '\['
          scope: meta.sexp.begin.clojure punctuation.section.brackets.begin.clojure
          set:
          - include: metadata
          - include: comment
          - meta_scope: meta.function.parameters.clojure
          - match: '\]'
            scope: meta.sexp.end.clojure punctuation.section.brackets.end.clojure
            set: class-specs

  interface-specs:
    - include: comment
    - include: string
    - match: '\('
      scope: meta.sexp.begin.clojure punctuation.section.parens.begin.clojure
      set:
        - include: metadata
        - match: '{{symbol}}'
          scope: meta.reader-form.clojure meta.symbol.clojure entity.name.function.clojure
          set:
          - match: '\['
            scope: meta.sexp.begin.clojure punctuation.section.brackets.begin.clojure
            set:
            - meta_scope: meta.function.parameters.clojure
            - match: '\]'
              scope: meta.sexp.end.clojure punctuation.section.brackets.end.clojure
              pop: true
              set:
                - match: '\)'
                  scope: meta.sexp.end.clojure punctuation.section.parens.end.clojure
                  set: interface-specs
            - include: main
    - include: list-tail

  typedef-tail:
    - include: list-end
    - match: '{{symbol}}'
      scope: meta.reader-form.clojure meta.symbol.clojure entity.name.type.clojure
      set:
        - match: \)
          scope: punctuation.section.parens.end.clojure
          pop: true
        - include: interface-specs
        - include: list-tail
    - include: list-tail

  def-tail:
    - match: '{{constant}}'
      scope: constant.language.clojure
      set: list-tail
    - match: '{{symbol}}'
      scope: meta.reader-form.clojure meta.symbol.clojure entity.name.constant.clojure
      set: list-tail
    - include: list-tail

  declare-tail:
    - match: '{{symbol}}'
      scope: meta.reader-form.clojure meta.symbol.clojure entity.name.variable.forward-decl.clojure
    - include: list-tail

  deftest-tail:
    - match: '{{symbol}}'
      scope: meta.reader-form.clojure meta.symbol.clojure entity.name.function.clojure meta.test-var.clojure
      set: list-tail
    - include: list-tail

  list-tail:
    - include: list-end
    - include: main

  list-end:
    - match: '\)'
      scope: meta.sexp.end.clojure punctuation.section.parens.end.clojure
      pop: true

  # Vector

  vector:
    - match: '\['
      scope: meta.sexp.begin.clojure punctuation.section.brackets.begin.clojure
      push:
      - match: '\]'
        scope: meta.sexp.end.clojure punctuation.section.brackets.end.clojure
        pop: true
      - include: main

  # Map

  map:
    - match: '\{'
      scope: meta.sexp.begin.clojure punctuation.section.braces.begin.clojure
      push:
      - match: \}
        scope: meta.sexp.end.clojure punctuation.section.braces.end.clojure
        pop: true
      - include: main

  # Set

  set:
    - match: '(#)(\{)'
      scope: punctuation.section.braces.begin.clojure
      captures:
        1: meta.sexp.prefix.clojure keyword.operator.macro.clojure
        2: meta.sexp.begin.clojure
      push:
      - match: \}
        scope: meta.sexp.end.clojure punctuation.section.braces.end.clojure
        pop: true
      - include: main

  stray-brackets:
    - match: '[\]\)\}]'
      scope: invalid.illegal.stray-bracket-end.clojure
